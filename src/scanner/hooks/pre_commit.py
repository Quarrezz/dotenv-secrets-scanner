"""Pre-commit hook management.

Provides functionality to install, uninstall, and run the secrets scanner
as a Git pre-commit hook. Compatible with both direct hook installation
and the pre-commit framework.
"""

from __future__ import annotations

import logging
import os
import stat
import sys
from pathlib import Path

from scanner.utils.git import get_repo_root, scan_staged_files

logger = logging.getLogger("scanner")

_HOOK_MARKER = "# dotenv-secrets-scanner pre-commit hook"

_HOOK_SCRIPT = f"""\
#!/usr/bin/env python3
{_HOOK_MARKER}
# Auto-generated by dotenv-secrets-scanner. Do not edit manually.
import subprocess
import sys

result = subprocess.run(
    [sys.executable, "-m", "scanner.hooks.pre_commit", "--run"],
    capture_output=False,
)
sys.exit(result.returncode)
"""


def install_hook(repo_path: Path | None = None) -> Path:
    """Install the pre-commit hook into a Git repository.

    Creates or updates the .git/hooks/pre-commit file. If a hook already
    exists, it is backed up to pre-commit.backup.

    Args:
        repo_path: Path to the repository. Auto-detected if None.

    Returns:
        Path to the installed hook file.

    Raises:
        FileNotFoundError: If no Git repository is found.
        OSError: If the hook cannot be written.
    """
    root = _resolve_repo_root(repo_path)
    hooks_dir = root / ".git" / "hooks"
    hooks_dir.mkdir(parents=True, exist_ok=True)

    hook_path = hooks_dir / "pre-commit"

    # Check for existing hook
    if hook_path.exists():
        existing = hook_path.read_text(encoding="utf-8", errors="replace")
        if _HOOK_MARKER in existing:
            logger.info("Hook already installed, updating: %s", hook_path)
        else:
            # Backup existing hook
            backup_path = hooks_dir / "pre-commit.backup"
            hook_path.rename(backup_path)
            logger.info("Existing hook backed up to: %s", backup_path)

    hook_path.write_text(_HOOK_SCRIPT, encoding="utf-8")

    # Make executable on Unix
    if os.name != "nt":
        current_mode = hook_path.stat().st_mode
        hook_path.chmod(current_mode | stat.S_IEXEC | stat.S_IXGRP | stat.S_IXOTH)

    logger.info("Pre-commit hook installed: %s", hook_path)
    return hook_path


def uninstall_hook(repo_path: Path | None = None) -> bool:
    """Remove the secrets scanner pre-commit hook.

    Only removes the hook if it was installed by this tool (checks for marker).

    Args:
        repo_path: Path to the repository. Auto-detected if None.

    Returns:
        True if the hook was removed, False if not found or not ours.

    Raises:
        FileNotFoundError: If no Git repository is found.
    """
    root = _resolve_repo_root(repo_path)
    hook_path = root / ".git" / "hooks" / "pre-commit"

    if not hook_path.exists():
        logger.info("No pre-commit hook found.")
        return False

    content = hook_path.read_text(encoding="utf-8", errors="replace")
    if _HOOK_MARKER not in content:
        logger.warning("Pre-commit hook was not installed by secrets-scanner, skipping.")
        return False

    hook_path.unlink()
    logger.info("Pre-commit hook removed: %s", hook_path)

    # Restore backup if exists
    backup_path = root / ".git" / "hooks" / "pre-commit.backup"
    if backup_path.exists():
        backup_path.rename(hook_path)
        logger.info("Previous hook restored from backup.")

    return True


def run_pre_commit_scan(repo_path: Path | None = None) -> int:
    """Run the pre-commit scan on staged files.

    This is the entry point called by the Git hook script.

    Args:
        repo_path: Path to the repository. Auto-detected if None.

    Returns:
        Exit code: 0 if clean, 1 if secrets found.
    """
    root = _resolve_repo_root(repo_path)
    findings = scan_staged_files(root)

    if not findings:
        print("âœ… Pre-commit scan: No secrets detected.")
        return 0

    print(f"\nðŸš¨ Pre-commit scan: {len(findings)} secret(s) detected!\n")

    for finding in findings:
        print(f"  [{finding.severity.name}] {finding.pattern_name}")
        print(f"    File: {finding.file_path}:{finding.line_number}")
        print(f"    Secret: {finding.masked_secret}")
        if finding.recommendation:
            print(f"    ðŸ’¡ {finding.recommendation}")
        print()

    print("âŒ Commit blocked. Please remove or secure the detected secrets.")
    print("   Use 'secrets-scan' for detailed information.")
    print("   To bypass: git commit --no-verify (not recommended)\n")

    return 1


def _resolve_repo_root(repo_path: Path | None) -> Path:
    """Resolve the Git repository root.

    Args:
        repo_path: Explicit path, or None for auto-detection.

    Returns:
        Repository root path.

    Raises:
        FileNotFoundError: If no Git repo is found.
    """
    if repo_path is None:
        repo_path = Path.cwd()

    root = get_repo_root(repo_path)
    if root is None:
        raise FileNotFoundError(
            f"No Git repository found at or above: {repo_path}"
        )
    return root


# Allow running as a module: python -m scanner.hooks.pre_commit --run
if __name__ == "__main__":
    if "--run" in sys.argv:
        sys.exit(run_pre_commit_scan())
    else:
        print("Usage: python -m scanner.hooks.pre_commit --run")
        sys.exit(2)
